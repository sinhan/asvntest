<?xml version="1.0"?>
<document index="yes">

<properties>
  <title>User's Manual: Samplers</title>
</properties>

<body>


<section name="13.1 Samplers" anchor="samplers">

<component index="13.1.1" name="FTP Request" screenshot="../images/screenshots/gen-controller/ftp-request.gif">
<description>This controller lets you send an FTP "retrieve file" request to an FTP server.
If you are going to send multiple requests to the same FTP server, consider
using a <complink name="FTP Request Defaults"/> Configuration
Element so you do not have to enter the same information for each FTP Request Generative
Controller. </description>
<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
	<property name="Server Name or IP" required="Yes">Domain name or IP address of the FTP server.
JMeter assumes the FTP server is listening on the default port.</property>
	<property name="File to Retrieve From Server" required="Yes">Path and name of the file to retrieve.</property>
	<property name="Username" required="Usually">FTP account username.</property>
	<property name="Password" required="Usually">FTP account password.</property>
</properties>
<links>
	<link href="test_plan.html#assertions">Assertions</link>
	<complink name="FTP Request Defaults"/>
	<link href="build-ftp-test-plan.html">Building an FTP Test Plan</link>
</links>

</component>

<component name="HTTP Request" index="13.1.2" screenshot="../images/screenshots/gen-controller/http-request.gif">

<description>
	<p>This controller lets you send an HTTP/HTTPS request to a web server.  It
	also lets you control whether or not JMeter parses HTML files for images and
	Java applets and sends HTTP requests to retrieve them.</p>
	<p>If you are going to send multiple requests to the same web server, consider
	using an <complink name="HTTP Request Defaults"/>
	Configuration Element so you do not have to enter the same information for each
	HTTP Request controller.</p>

	<p>Or, instead of manually adding HTTP Request controllers, you may want to use
	JMeter's <complink name="HTTP Proxy Server"/> to create
	them.  This can save you time if you have a lot of HTTP requests or requests with many
	parameters.</p>

	<p>If the request requires a login authorization, you will also have to add an
	<complink name="HTTP Authorization Manager"/>
	Configuration Element. And, if the request uses cookies, then you will also need an
	<complink name="HTTP Cookie Manager"/>.  You can
	add either of these elements to the Thread Group or the HTTP Request.  If you have
	more than one HTTP Request that needs authorizations or cookies, then add the
	elements to the Thread Group.  That way, all HTTP Request controllers will share the
	same Authorization Manager and Cookie Manager elements.</p>

	<p>If the request uses a technique called "URL Rewriting" to maintain sessions,
	then see section
	<a href="build-adv-web-test-plan.html#url_rewriting">6.x HTTP Requests and Session ID's: URL Rewriting</a>
	for additional configuration steps.</p>
</description>

<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
	<property name="Server" required="Yes">Domain name or IP address of the web server.</property>
	<property name="Port" required="No (defaults to 80)">Port the web server is listening to.</property>
	<property name="Protocol" required="Yes">HTTP or HTTPS.</property>
	<property name="Method" required="Yes">HTTP GET or HTTP POST.</property>
	<property name="Path" required="Yes">The path to resource (for example, /servlets/myServlet). If the
resource requires query string parameters, add them below in the
"Send Parameters With the Request" section.</property>
	<property name="Send Parameters With the Request" required="No">The query string will
	be generated from the list of parameters you provide.  Each parameter has a <i>name</i> and
	<i>value</i>.  The query string will be generated in the correct fashion, depending on
	the choice of "Method" you made (ie if you chose GET, the query string will be
	appended to the URL, if POST, then it will be sent separately).  Also, if you are
	sending a file using a multipart form, the query string will be created using the
	multipart form specifications.</property>
	<property name="Filename" required="No">Name of the file to send.  If left blank, JMeter
	does not send a file, if filled in, JMeter automatically sends the request as
	a multipart form request.</property>
	<property name="Parameter Name" required="No (Yes if Filename filled in)">Name of the web request parameter.</property>
	<property name="MIME Type" required="No (Yes if Filename filled in)">MIME type (for example, text/plain).</property>
	<property name="Retrieve All Images and Java Applets" required="No">Tell JMeter to parse the HTML file
and send HTTP/HTTPS requests for all images and Java applets referenced in the file.</property>
</properties>

<links>
	<link href="test_plan.html#assertions">Assertion</link>
	<link href="build-web-test-plan.html">Building a Web Test Plan</link>
	<link href="build-adv-web-test-plan.html">Building an Advanced Web Test Plan</link>
	<complink name="HTTP Authorization Manager"/>
	<complink name="HTTP Cookie Manager"/>
	<complink name="HTTP Header Manager"/>
	<complink name="HTML Link Parser"/>
	<complink name="HTTP Proxy Server"/>
	<complink name="HTTP Request Defaults"/>
	<link href="build-adv-web-test-plan.html#url_rewriting">HTTP Requests and Session ID's: URL Rewriting</link>
</links>

</component>

<component name="JDBC Request" index="13.1.3" screenshot="../images/screenshots/gen-controller/jdbc-request.gif">

<description><p>This controller lets you send an JDBC Request (an SQL query) to a database.</p>
<p>If you are going to send multiple requests to the same database, consider
using one or more of the Defaults Configuration Elements:
<complink name="JDBC Database Login Defaults"/>,
<complink name="JDBC Database Connection Pool Defaults"/>,
<complink name="JDBC SQL Query Defaults"/>.
This way, you do not have to enter the same information for each JDBC Request
controller.</p></description>

<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
	<property name="JDBC URL" required="Yes">URL of the database (for example,
"jdbc:weblogic:oracle"). Refer to your database's JDBC documentation for the
URL you should use.</property>
	<property name="Driver Class" required="Yes">The database driver Java class (for example,
"weblogic.jdbc.oci.Driver"). Refer to your database's JDBC documentation for
the name of the JDBC driver class you should use.</property>
	<property name="Username" required="Usually (database dependent)">FTP account username.</property>
	<property name="Password" required="Usually (database dependent)">FTP account password.</property>
	<property name="Number of Connections in Pool" required="Yes">Number of database connection
instances to create and keep active. The maximum value depends on your database.
Also, JMeter imposes a maximum of 100 connections.</property>
	<property name="Max Usage For Each Connection" required="Yes">Maximum number of times JMeter
uses a database connection instance before recycling it (destroying and creating
a new instance).</property>
	<property name="SQL Query String" required="Yes">SQL query (for example, "select * from t_customers").</property>
</properties>

<links>
	<link href="test_plan.html#assertions">Assertion</link>
	<link href="build-db-test-plan.html">Building a Database Test Plan</link>
	<complink name="JDBC Database Login Defaults"/>
	<complink name="JDBC Database Connection Pool Defaults"/>
	<complink name="JDBC SQL Query Defaults"/>
</links>

</component>

<component index="13.1.4" name="JNDI Request" screenshot="">

<properties>
	<property name="java.naming.factory.initial" required=""></property>
	<property name="java.naming.factory.object" required=""></property>
	<property name="java.naming.factory.state" required=""></property>
	<property name="java.naming.factory.url.pkgs" required=""></property>
	<property name="java.naming.provider.url" required=""></property>
	<property name="java.naming.dns.url" required=""></property>
	<property name="java.naming.authoritative" required=""></property>
	<property name="java.naming.batchsize" required=""></property>
	<property name="java.naming.referral" required=""></property>
	<property name="java.naming.security.protocol" required=""></property>
	<property name="java.naming.security.authentication" required=""></property>
	<property name="java.naming.security.principal" required=""></property>
	<property name="java.naming.security.credentials" required=""></property>
	<property name="java.naming.language" required=""></property>
	<property name="java.naming.applet" required=""></property>
</properties>
</component>
</section>

<section name="13.2 Logic Controllers" anchor="logic_controllers">

<component index="13.2.1" name="Interleave Controller" screenshot="../images/screenshots/logic-controller/interleave-controller.gif">
<description><p>If you add Generative or Logic Controllers to an Interleave Controller, JMeter will alternate among each of the
other controllers for each loop iteration. </p>
</description>
<properties>
	<property name="name" required="No">Descriptive name for this controller that is shown in the tree.</property>
</properties>

<!--
For example, if you
add three HTTP Requests to an Interleave Controller and configure the Thread
Group to loop, here is the sequence in which JMeter sends the requests:
</p>
<table border="1" cellspacing="0" cellpadding="4">
<tr valign="top"><td>Loop Iteration</td><td>Description</td></tr>
<tr valign="top"><td>1</td><td>JMeter sends the first HTTP Request.</td></tr>
<tr valign="top"><td>2</td><td>JMeter sends the second HTTP Request.</td></tr>
<tr valign="top"><td>3</td><td>JMeter sends the third HTTP Request.</td></tr>
<tr valign="top"><td>4</td><td>Because there are no more requests in controller, JMeter start over and sends the first HTTP Request.</td></tr>
<tr valign="top"><td>5</td><td>JMeter sends the second HTTP Request.</td></tr>
<tr valign="top"><td>(and so on)</td><td>...</td></tr>
</table>
-->
<example title="Simple Interleave Example" anchor="simple_interleave_example">

<p><a href="../demos/InterleaveTestPlan.jmx">Download</a> this example (see Figure 1).  In this example,
we configured the Thread Group to have two threads and a loop count of five, for a total of ten
requests. See the table below for the sequence JMeter sends the HTTP Requests.</p>

<figure image="../images/screenshots/logic-controller/interleave.gif">Figure 1 - Interleave Controller Example 1</figure>

<table border="1" cellspacing="0" cellpadding="4">
<tr valign="top"><td>Loop Iteration</td><td>Each JMeter Thread Sends These HTTP Requests</td></tr>
<tr valign="top"><td>1</td><td>News Page</td></tr>
<tr valign="top"><td>2</td><td>FAQ Page</td></tr>
<tr valign="top"><td>3</td><td>Gump Page</td></tr>
<tr valign="top"><td>4</td><td>Because there are no more requests in controller, JMeter start over and sends the first HTTP Request, which is the News Page.</td></tr>
<tr valign="top"><td>5</td><td>FAQ Page</td></tr>
</table>

<p>Note, the File Reporter is configured to store the results in a file named
"interleave-test.dat" in the current directory.</p>

</example>

<example title="Useful Interleave Example" anchor="useful_interleave_example">

<p><a href="../demos/InterleaveTestPlan2.jmx">Download</a> another example (see Figure 2).  In this
example, we configured the Thread Group
to have a single thread and a loop count of eight.  Notice that the Test Plan has an outer Interleave Controller with
two Interleave Controllers inside of it.</p>

<figure image="../images/screenshots/logic-controller/interleave2.gif">
	Figure 2 - Interleave Controller Example 2
</figure>

<p>The outer Interleave Controller alternates between the
two inner ones.  Then, each inner Interleave Controller alternates between each of the HTTP Requests.  Each JMeter
thread will send the requests in the following order: Home Page, Bug Page, CVS Page, and FAQ Page.
Note, the File Reporter is configured to store the results in a file named "interleave-test2.dat" in the current directory.</p>
</example>
</component>

<component index="13.2.2" name="Loop Controller" anchor="loop" screenshot="../images/screenshots/logic-controller/loop-controller.gif">
<description><p>If you add Generative or Logic Controllers to a Loop Controller, JMeter will
loop through them a certain number of times, in addition to the loop value you
specified for the Thread Group.  For example, if you add one HTTP Request to a
Loop Controller with a loop count of two, and configure the Thread Group loop
count to three, JMeter will send a total of 2 * 3 = 6 HTTP Requests.
</p></description>

<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
	<property name="Loop Count" required="Yes, unless &quot;Forever&quot; is checked">
		The number of times the subelements of this controller will be iterated each time
		through a test run.
		<p><b>Special Case:</b> The Loop Controller embedded in the <a href="test_plan.html#thread_group">Thread Group</a>
		element behaves slightly differently.  Unless set to forever, it stops the test after
		the given number of iterations have been done.</p></property>
</properties>

<example title="Looping Example" anchor="loop_example">

<p><a href="../demos/LoopTestPlan.jmx">Download</a> this example (see Figure 3).
In this example, we created a Test Plan that sends a particular HTTP Request
only once and sends another HTTP Request five times.</p>

<figure image="../images/screenshots/logic-controller/loop-example.gif">Figure 3 - Loop Controller Example</figure>

<p>We configured the Thread Group for a single thread and a loop count value of
one. Instead of letting the Thread Group control the looping, we used a Loop
Controller.  You can see that we added one HTTP Request to the Thread Group and
another HTTP Request to a Loop Controller.  We configured the Loop Controller
with a loop count value of five.</p>
<p>JMeter will send the requests in the following order: Home Page, News Page,
News Page, News Page, News Page, and News Page. Note, the File Reporter
is configured to store the results in a file named "loop-test.dat" in the current directory.</p>

</example>

</component>

<component index="13.2.3" name="Modification Manager" anchor="modification_manager">
<description>
<p>This element has no visual elements, and needs no configuration.
The Modification Manager acts as a container for Modifier elements (which
are special kinds of Configuration Elements).</p>

<p>The Modification Manager can be used to introduce dynamic data into a test script.  As test samples pass through the
Modification Manager, it has the opportunity to modify them.  The Modification Manager holds Modifier elements which it
 uses to control how it modifies test samples.  If no Modifier elements are added, the Modification Manager has no effect.</p>

<p>There are two types of Modifiers.  Regular Modifiers (currently there aren't any implemented Modifiers), and response
based Modifiers (there is one HTML response based Modifier).</p>
</description>

<links>
	<complink name="HTML Link Parser"/>
</links>
</component>

<component index="13.2.4" name="Once Only Controller" anchor="once_only_controller"
screenshot="../images/screenshots/logic-controller/once-only-controller.gif">
<description>
<p>The Once Only Logic Controller tells JMeter to process the controller(s) inside it only once, regardless of the loop
count value you specify in the Thread Group or Loop Controller.</p>

<p>For testing that requires a login, consider placing the login request in this controller since each thread only needs
to login once to establish a session.</p>
</description>
<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
</properties>

<example title="Once Only Example" anchor="once_only_example">
<p><a href="../demos/OnceOnlyTestPlan.jmx">Download</a> this example (see Figure 4).
In this example, we created a Test Plan that has two threads that send HTTP request.
Each thread sends one request to the Home Page, followed by three requests to the Bug Page.
Although we configured the Thread Group to iterate three times, each JMeter thread only
sends one request to the Home Page because this request lives inside a Once Only Controller.</p>
<figure image="../images/screenshots/logic-controller/once-only-example.gif">Figure 4. Once Only Controller Example</figure>
<p>Each JMeter thread will send the requests in the following order: Home Page, Bug Page,
Bug Page, Bug Page. Note, the File Reporter is configured to store the results in a file named "loop-test.dat" in the current directory.</p>

</example>
</component>

<component index="13.2.5" name="Simple Controller" anchor="simple_controller" screenshot="../images/screenshots/logic-controller/simple-controller.gif">
<description>
<p>The Simple Logic Controller lets  you organize your Samplers and other
Logic Controllers.  Unlike other Logic Controllers, this controller provides no functionality beyond that of a
storage device.</p>
</description>
<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
</properties>

<example title="Using the Simple Controller" anchor="simple_controller_example">
<p><a href="../demos/SimpleTestPlan.jmx">Download</a> this example (see Figure 5).
In this example, we created a Test Plan that sends two Ant HTTP requests and two
Log4J HTTP requests.  We grouped the Ant and Log4J requests by placing them inside
Simple Logic Controllers.  Remember, the Simple Logic Controller has no effect on how JMeter
processes the controller(s) you add to it.  So, in this example, JMeter sends the requests in the
following order: Ant Home Page, Ant News Page, Log4J Home Page, Log4J History Page.
Note, the File Reporter
is configured to store the results in a file named "simple-test.dat" in the current directory.</p>
<figure image="../images/screenshots/logic-controller/simple-example.gif">Figure 5 Simple Controller Example</figure>

</example>
</component>
</section>

<section name="13.3 Listeners" anchor="listeners">

<component index="13.3.1" name="View Graph Tree" screenshot="">
<description>No Description</description>
</component>

<component index="13.3.2" name="Graph Full Results" screenshot="">
<description>No Description</description>
</component>

<component index="13.3.3" name="Graph Results" screenshot="../images/screenshots/graph_results.gif">
<description><p>The Graph Results listener generates a simple graph that plots all sample times.  Along
the right side of the graph, the current sample (black), the current average of all samples(blue), and the
current standard deviation (red) are displayed in milliseconds.</p></description>
</component>

<component index="13.3.4" name="Spline Visualizer" screenshot="../images/screenshots/spline_visualizer.gif">
<description><p>The Spline Visualizer provides a view of all sample times from the start
of the test till the end, regardless of how many samples have been taken.  The spline
has 10 points, each representing 10% of the samples, and connected using spline
logic to show a single continuous line.</p></description>
</component>

<component index="13.3.5" name="Assertion Results" screenshot="../images/screenshots/assertion_results.gif">
<description><p>The Assertion Results visualizer shows the URL of each sample taken (no time information
is shown).  It also reports failures of any <a href="test_plan.html#assertions">Assertions</a> that
are part of the test plan.</p></description>

<links>
	<complink name="Basic Assertion"/>
</links>
</component>

<component index="13.3.6" name="File Reporter" screenshot="../images/screenshots/file_reporter.gif">
<description>The File Reporter records sample data to a file.</description>

<properties>
	<property name="Filename" required="Yes">Name of file to save samples to.</property>
	<property name="Append to Existing Data File" required="No">If yes, then data is appended to the
	end of the file.  If no, then JMeter erases the previous contents of the file when you hit "Open".</property>
	<property name="Automatically Flush Data After Each Sample" required="No">Normally, the file is
	not written continuously.  If selected, each sample will be written to the file as it comes in.</property>
	<property name="Verbose Output" required="No">Sample Verbose Output:
	<blockquote><pre>
# Sample data created by null

#       URL                    Milliseconds

http://jakarta.apache.org/ 1650,
http://jakarta.apache.org/ 1920,
http://jakarta.apache.org/ 1200,
http://jakarta.apache.org/ 1650,
http://jakarta.apache.org/ 1700,
http://jakarta.apache.org/ 1980,</pre></blockquote>
Sample Non-Verbose Output:
<blockquote><pre>4440
4830
6540
5550
3080
3350</pre></blockquote></property>
	<property name="Include Submitted Data" required="No">This will include all data JMeter sent
	with the request, beyond the URL (ie POSTed data for web testing, SQL statements for
	database testing).</property>
	<property name="Open" required="Yes (in a sense)">Until you hit "Open", no sample data will be
	recorded.  Normally, you would do this before starting the test.</property>
	<property name="Flush" required="No">Sends all data collected to the file.  If "Automatically Flush Data After Each Sample"
	was selected, this is unnecessary.</property>
	<property name="Close" required="No">Closes the file, flushing all collected data at the same time.</property>
</properties>
</component>

<component index="13.3.7" name="View Results" screenshot="../images/screenshots/view_results.gif">
<description>The View Results visualizer displays the response from the server.  No time information
is given.  Hit the "Next" button to view the next sample response.  Consider using the
<complink name="View Result_Tree"/> instead.</description>
</component>

<component index="13.3.8" name="View Result Tree" screenshot="../images/screenshots/view_result_tree.gif">
<description>The View Results Tree shows a tree of all sample responses, allowing you to view the
response for any sample.  In addition to showing the response, you can see the time it took to get
this response, and some response codes.</description>
</component>

</section>

<section name="13.4 Configuration Elements" anchor="config_elements">

<component index="13.4.1" name="HTTP Authorization Manager" screenshot="../images/screenshots/http-config/http-auth-manager.gif">

<description>
<p>The Authorization Manager lets you specify one or more user logins for web pages that are
restricted using Basic HTTP Authentication.  You see this type of authentication when you use
your browser to access a restricted page, and your browser displays a login dialog box.  JMeter
transmits the login information when it encounters this type of page.</p>

<note>In the current release, all JMeter threads in a Thread Group use the same username/password
for a given Base URL even if you create multiple users with the same Base URL in the authorization table.
We plan to correct this in a future release.  As a workwaround, you can create multiple Thread Groups for your
Test Plan, with each Thread Group having its own Authorization Manager.
</note>
</description>

<properties>
	<property name="Name" required="No">Descriptive name for this element that is shown in the tree. </property>
  <property name="Base URL" required="Yes">A partial or complete URL that matches one or more HTTP Request URLs.  As an example,
say you specify a Base URL of "http://jakarta.apache.org/restricted/" with a username of "jmeter" and
a password of "jmeter".  If you send an HTTP request to the URL
"http://jakarta.apache.org/restricted/ant/myPage.html", the Authorization Manager sends the login
information for the user named, "jmeter".</property>
  <property name="Username" required="Yes">The username to authorize.</property>
  <property name="Password" required="Yes">The password to authorize.</property>
</properties>
<b>Controls:</b>
<ul>
  <li>Add Button - Add an entry to the authorization table.</li>
  <li>Delete Button - Delete the currently selected table entry.</li>
  <li>Load Button - Load a previously saved authorization table and add the entries to the existing
authorization table entries.</li>
  <li>Save As Button - Save the current authorization table to a file.</li>
</ul>

<note>When you save the Test Plan, JMeter automatically saves all of the authorization
table entries.</note>

<example title="Authorization Example" anchor="authorization_example">

<p><a href="../demos/AuthManagerTestPlan.jmx">Download</a> this example.  In this example, we created a Test Plan on a local server that sends three HTTP requests, two requiring a login and the
other is open to everyone.  See figure 6 to see the makeup of our Test Plan.  On our server, we have a restricted
directory named, "secret", which contains two files, "index.html" and "index2.html".  We created a login id named, "kevin",
which has a password of "spot".  So, in our Authorization Manager, we created an entry for the restricted directory and
a username and password (see figure 7).  The two HTTP requests named "SecretPage1" and "SecretPage2" make requests
to "/secret/index1.html" and "/secret/index2.html".  The other HTTP request, named "NoSecretPage" makes a request to
"/index.html".</p>

<figure image="../images/screenshots/http-config/auth-manager-example1a.gif">Figure 6 - Test Plan</figure>
<figure image="../images/screenshots/http-config/auth-manager-example1b.gif">Figure 7 - Authorization Manager Control Panel</figure>

<p>When we run the Test Plan, JMeter looks in the Authorization table for the URL it is requesting.  If the Base URL matches
the URL, then JMeter passes this information along with the request.</p>

<note>You can download the Test Plan, but since it is built as a test for our local server, you will not
be able to run it.  However, you can use it as a reference in constructing your own Test Plan.</note>
</example>

</component>

<component index="13.4.2" name="HTTP Cookie Manager" screenshot="../images/screenshots/http-config/http-cookie-manager.gif">

<description><p>The Cookie Manager element has two functions:<br/>
First, it stores and sends cookies just like a web browser. If you
have an HTTP Request and the response contains a cookie, the Cookie Manager automatically stores that cookie and will use
if, for all future request that particular request.  Each JMeter thread has its own "cookie storage area".  So, if you
are testing a web site that uses a cookie for storing session information, each JMeter thread will have its own session.</p>

<p>Second, you can manually add a cookie to the Cookie Manager.  However, if you do this, the cookie will be
shared by all JMeter threads.</p>
</description>
<properties>
	<property name="Name" required="No">Descriptive name for this element that is shown in the tree. </property>
  <property name="Cookies Stored in the Cookie Manager" required="No (discouraged, unless you know what you're doing)">This
  gives you the opportunity to use hardcoded cookies that will be used by all threads during the test execution.</property>
  <property name="Add Button" required="N/A">Add an entry to the cookie table.</property>
  <property name="Delete Button" required="N/A">Delete the currently selected table entry.</property>
  <property name="Load Button" required="N/A">Load a previously saved cookie table and add the entries to the existing
cookie table entries.</property>
  <property name="Save As Button" required="N/A">Save the current cookie table to a file.</property>
</properties>

</component>

<component index="13.4.3" name="HTTP Proxy Server" screenshot="../images/screenshots/http-config/http-proxy-server.gif">

<description><p>The Proxy Server allows JMeter to watch and record your actions while you browse your web application
with your normal browser (such as Internet Explorer).  JMeter will create test sample objects and store them
directly into your test plan as you go (so you can view samples interactively while you make them).</p>

<p>To use the proxy server, <i>add</i> the HTTP Proxy Server element to the workbench.  It will
appear under the Configuration Element menu list (Add->Config Elements->HTTP Proxy Server).</p>
</description>

<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
	<property name="Port" required="Yes">The port that the Proxy Server listens to.  8080 is the default, but you can change it
if that port is already in use on your machine.</property>
	<property name="Patterns to Include" required="No">Regular expressions that are matched against the full URL that is sampled.  Allows filtering of requests that are recorded.  All requests pass through, but only
	those that meet the requirements of the Include/Exclude fields are <i>recorded</i>.  If both Include and Exclude are
	left empty, then everything is recorded (which can result in dozens of samples recorded for each page, as images, stylesheets,
	etc are recorded).  <b>If there is at least one entry in the Include field, then only requests that match one or more Include patterns are
	recorded</b>.</property>
	<property name="Patterns to Exclude" required="No">Regular expressions that are matched against the URL that is sampled.
	<b>Any requests that match one or more Exclude pattern are <i>not</i> recorded</b>.</property>
	<property name="Clear Buttons" required="N/A">Remove all regular expressions from the list.</property>
  <property name="Start Button" required="N/A">Start the proxy server.  JMeter writes the following message to the console once the proxy server
has started up and is ready to take requests: "Proxy up and running!".</property>
  <property name="Stop Button" required="N/A">Stop the proxy server.</property>
</properties>

<p>To add an entry to the Include or Exclude field, type the entry into the text field, and hit &quot;Enter&quot; when done.
The text will be added to the List box to the right of the text field.  To clear the text field, hit the &quot;clear&quot;
button.  Currently, there is no way to individually select items and delete them.</p>

<p>These entries will be treated as Perl-type regular expressions.  They will be matched against the host name + the path of
each browser request.  Thus, if the URL you are browsing is http://jakarta.apache.org/jmeter/index.html?username=xxxx,
then the regular expression will be tested against the string: &quot;jakarta.apache.org/jmeter/index.html&quot;.  Thus,
if you wanted to include all .html files, you're regular expression might look like: &quot;.*\.html&quot;.  Using a
combination of includes and excludes, you should be able to record what you are interested in and skip what you are
not.</p>

<p>When you are ready to begin, hit &quot;start&quot;.</p>
<note>You will need to edit the proxy settings of your browser to point at the
appropriate server and port, where the server is the machine JMeter is running on, and
the port # is from the Proxy Control Panel shown above.</note>

<b>Where Do Samples Get Recorded?</b>
<p>JMeter places the recorded samples in the Thread Group, or if you have a Simple Logic Controller,  JMeter places
them there.  Also, if you have a HTTP Request Defaults element, then the recorded samples will have empty fields for
the default values you specified.</p>
<note>If you have more than one Simple Logic Controller, JMeter records the samples to each
of your Simple Logic Controllers.  We plan to correct this in a future release.</note>

<p>When you are done recording your test samples, stop the proxy server (hit the &quot;stop&quot; button).  Remember to reset
your browser's proxy settings.  Now, you may want to sort and re-order the test script, add timers, listeners, a
cookie manager, etc.</p>

</component>

<component index="13.4.4" name="HTTP Request Defaults"
	screenshot="../images/screenshots/http-config/http-request-defaults.gif">
<description><p>This element lets you set default values that your HTTP Request controllers use.  For example, if you are
creating a Test Plan with 25 HTTP Request controllers and all of the requests are being sent to the same server,
you could add a single HTTP Request Defaults element with the "Server Name or IP" field filled in.  Then, when
you add the 25 HTTP Request controllers, leave the "Server Name or IP" field empty.  The controllers will inherit
this field value from the HTTP Request Defaults element.</p>
</description>

<properties>
	<property name="Name" required="No">Descriptive name for this controller that is shown in the tree.</property>
	<property name="Server" required="Yes">Domain name or IP address of the web server.</property>
	<property name="Port" required="No (defaults to 80)">Port the web server is listening to.</property>
	<property name="Protocol" required="Yes">HTTP or HTTPS.</property>
	<property name="Method" required="Yes">HTTP GET or HTTP POST.</property>
	<property name="Path" required="Yes">The path to resource (for example, /servlets/myServlet). If the
resource requires query string parameters, add them below in the
"Send Parameters With the Request" section.</property>
	<property name="Send Parameters With the Request" required="No">The query string will
	be generated from the list of parameters you provide.  Each parameter has a <i>name</i> and
	<i>value</i>.  The query string will be generated in the correct fashion, depending on
	the choice of "Method" you made (ie if you chose GET, the query string will be
	appended to the URL, if POST, then it will be sent separately).  Also, if you are
	sending a file using a multipart form, the query string will be created using the
	multipart form specifications.</property>
</properties>
</component>

<component index="13.4.5" name="FTP Request Defaults"
		screenshot="../images/screenshots/ftp-config/ftp-request-defaults.gif">
<description></description>
</component>

<component index="13.4.6" name="JDBC Database Connection Pool Defaults"
		screenshot="../images/screenshots/jdbc-config/jdbc-db-conn-pool.gif">
<description></description>
</component>

<component index="13.4.7" name="JDBC Database Login Defaults"
		screenshot="../images/screenshots/jdbc-config/jdbc-db-login.gif">
<description></description>
</component>

<component index="13.4.8" name="JDBC SQL Query Defaults"
		screenshot="../images/screenshots/jdbc-config/jdbc-sql-query.gif">
<description></description>
</component>

<component index="13.4.9" name="HTML Link Parser" anchor="html_link_parser">
<description>
<p>This modifier parses HTML response from the server and extracts
links and forms.  A URL test sample that passes through this modifier will be examined to
see if it &quot;matches&quot; any of the links or forms extracted
from the immediately previous response.  It would then replace the values in the URL
test sample with appropriate values from the matching link or form.  Perl-type regular
expressions are used to find matches.</p>
</description>

<example title="Spidering Example" anchor="spider_example">
<p>Consider a simple example: let's say you wanted JMeter to &quot;spider&quot; through your site,
hitting link after link parsed from the HTML returned from your server (this is not
actually the most useful thing to do, but it serves as a good example).  You would create
a <complink anchor="modification_manager" name="Modification Manager"/>, and add the &quot;HTML Link Parser&quot; to it.  Then, create a
Web Test controller, and set the domain to &quot;.*&quot;, and the path likewise. This will
cause your test sample to match with any link found on the returned pages.  If you wanted to
restrict the spidering to a particular domain, then change the domain value
to the one you want.  Then, only links to that domain will be followed.
</p>
</example>

<example title="Poll Example" anchor="poll_example">
<p>A more useful example: given a web polling application, you might have a page with
several poll options as radio buttons for the user to select.  Let's say the values
of the poll options are very dynamic - maybe user generated.  If you wanted JMeter to
test the poll, you could either create test samples with hardcoded values chosen, or you
could let the HTML Link Parser parse the form, and insert a random poll option into
your URL test sample.  To do this, follow the above example, except, when configuring
your Web Test controller's URL options, be sure to choose &quot;POST&quot; as the
method.  Put in hard-coded values for the domain, path, and any additional form parameters.
Then, for the actual radio button parameter, put in the name (let's say it's called &quot;poll_choice&quot;),
and then &quot;.*&quot; for the value of that parameter.  When the modifier examines
this URL test sample, it will find that it &quot;matches&quot; the poll form (and
it shouldn't match any other form, given that you've specified all the other aspects of
the URL test sample), and it will replace your form parameters with the matching
parameters from the form.  Since the regular expression &quot;.*&quot; will match with
anything, the modifier will probably have a list of radio buttons to choose from.  It
will choose at random, and replace the value in your URL test sample.  Each time through
the test, a new random value will be chosen.</p>

<figure image="../images/screenshots/modification.gif">Figure 8 - Online Poll Example</figure>

<note>One important thing to remember is that you must create a test sample immediately
prior that will return an HTML page with the links and forms that are relevant to
your dynamic test sample.</note>
</example>

</component>

<component index="13.4.10" name="HTTP Header Manager" screenshot="../images/screenshots/http-config/http-header-manager.gif">
<description><p>The Header Manager lets you add or override HTTP request headers.</p>
</description>

<properties>
	<property name="Name" required="No">Descriptive name for this element that is shown in the tree. </property>
  <property name="Name (Header)" required="No (You should have at least one, however)">Name of the request header.
	Two common request headers you may want to experiment with
are "User-Agent" and "Referer".</property>
  <property name="Value" required="No (You should have at least one, however)">Request header value.</property>
  <property name="Add Button" required="N/A">Add an entry to the header table.</property>
  <property name="Delete Button" required="N/A">Delete the currently selected table entry.</property>
  <property name="Load Button" required="N/A">Load a previously saved header table and add the entries to the existing
header table entries.</property>
  <property name="Save As Button" required="N/A">Save the current header table to a file.</property>
</properties>

<example title="Header Manager example" anchor="header_manager_example">

<p><a href="../demos/HeaderManagerTestPlan.jmx">Download</a> this example.  In this example, we created a Test Plan
that tells JMeter to override the default "User-Agent" request header and use a particular Internet Explorer agent string
instead. (see figures 9 and 10).</p>

<figure image="../images/screenshots/http-config/header-manager-example1a.gif">Figure 9 - Test Plan</figure>
<figure image="../images/screenshots/http-config/header-manager-example1b.gif">Figure 10 - Header Manager Control Panel</figure>
</example>

</component>

<component index="13.4.11" name="JNDI Lookup Configuration" screenshot="">
<properties>
	<property name="Name">Descriptive name for this element that is shown in the tree.</property>
	<property name="Remote Interface"></property>
</properties>
</component>

<component index="13.4.12" name="JNDI Remote Method Configuration" screenshot="">
<properties>
	<property name="Name">Descriptive name for this element that is shown in the tree.</property>
	<property name="Home Method Name"></property>
	<property name="Home Method Parameters"></property>
	<property name="Remote Interfaces"></property>
	<property name="Remote Method Name"></property>
	<property name="Remote Method Parameters"></property>
	<property name="Reflect Button"></property>
</properties>
</component>
</section>

<section name="13.5 Assertions" anchor="assertions">

<component index="13.5.1" name="Basic Assertion" anchor="basic_assertion" screenshot="../images/screenshots/assertion/assertion.gif">

<description><p>The assertion control panel let's you add strings to be tested. These strings can
be regular expressions. You can also choose whether the strings will be expected
to match the entire response, or if the response is only expected to contain the
strings. You can attach multiple assertions to any controller for additionaly flexibility.</p>
</description>
<properties>
	<property name="Name" required="">Descriptive name for this element that is shown in the tree.</property>
	<property name="Response Field to Test" required="Yes">Instructs JMeter to test
		against either the Response Text from the server, or against the URL string that was sampled.</property>
	<property name="Pattern Matching Rules" required="Yes">Indicates whether the text being tested
	must CONTAIN or MATCH the test patterns.  NOT may also be selected to indicate the text
	should NOT CONTAIN or NOT MATCH the test patterns.</property>
	<property name="Patterns to Test" required="Yes">A list of regular expressions to
	be tested.  Each pattern is tested separately.  There is no difference between setting up
	one Assertion with multiple patterns and setting up multiple Assertions with one
	pattern each (assuming the other options are the same).</property>
</properties>

<example title="Assertion Examples" anchor="assertion_examples">
<figure image="../images/screenshots/assertion/example1a.gif">Figure 7 - Test Plan</figure>
<figure image="../images/screenshots/assertion/example1b.gif">Figure 8 - Assertion Control Panel with Pattern</figure>
<figure image="../images/screenshots/assertion/example1c-pass.gif">Figure 9 - Assertion Listener Results (Pass)</figure>
<figure image="../images/screenshots/assertion/example1c-fail.gif">Figure 10 - Assertion Listener Results (Fail)</figure>
</example>


</component>

</section>

<section name="13.6 Timers" anchor="timers">

<component index="13.6.1" name="Constant Timer" anchor="constant" screenshot="../images/screenshots/timers/constant_timer.gif">
<description>
<p>If you want to have each thread pause for the same amount of time between
requests, use this timer.</p></description>

<properties>
	<property name="Name" required="No">Descriptive name for this timer that is shown in the tree.</property>
	<property name="Thread Delay" required="Yes">Number of milliseconds to pause.</property>
</properties>
</component>

<component index="13.6.2" name="Gaussian Random Timer" screenshot="../images/screenshots/timers/gauss_random_timer.gif">

<description><p>This timer pauses each thread request for a random amount of time, with most
of the time intervals ocurring near a particular value.  The total delay is the
sum of the Gaussian distributed value (with mean 0.0 and standard deviation 1.0) times
the deviation value you specify, and the offset value.</p></description>


<properties>
	<property name="Name" required="No">Descriptive name for this timer that is shown in the tree</property>
  <property name="Deviation" required="Yes">Deviation in milliseconds.</property>
  <property name="Constant Delay Offset" required="Yes">Number of milliseconds to pause in addition
to the random delay.</property>
</properties>

</component>

<component index="13.6.3" name="Uniform Random Timer" screenshot="../images/screenshots/timers/uniform_random_timer.gif">

<description><p>This timer pauses each thread request for a random amount of time, with
each time interval having the same probability of occurring. The total delay
is the sum of the random value and the offset value.</p></description>

<properties>
	<property name="Name" required="No">Descriptive name for this timer that is shown in the tree. </property>
  <property name="Random Delay Maximum" required="Yes">Maxium random number of milliseconds to
pause.</property>
  <property name="Constant Delay Offset" required="Yes">Number of milliseconds to pause in addition
to the random delay.</property>
</properties>

</component>
</section>

<section name="13.7 Miscellaneous Features" anchor="Miscellaneous_Features">
<component index="13.7.1" name="Data Analyzer" screenshot="../images/screenshots/data_analyzer.gif">
<description><p>The Data Analyzer presents a graphical view of data stored using the <complink name="File Reporter"/>.</p>
<p>To use the Data Analyzer, goto the Report --&gt; Analyze Data File main menu option.  Then,
when prompted, select the file where the data is stored.  JMeter will present the data
as a graph with multiple lines.  Each line represents a different HTTP Request from your test and
its response times.</p></description>
</component>

<component index="13.7.2" name="SSL Manager" screenshot="">
<p>
  The SSL Manager is a way to select a client certificate so that you can test
  applications that use Public Key Infrastructure (PKI).  In order to use it,
  you must have JSSE 1.0.2 installed.  Unfortunately, there is no standard method
  for controling who a client is--and that won't be introduced until JDK 1.4 is
  officially available.  The SSL Manager should still work with JDK 1.4, so this
  is the best solution we could come up with.
</p>

<b>Choosing a Client Certificate</b>
<p>
  You may either use a Java Key Store (JKS) format key store, or a Public Key
  Certificate Standard #12 (PKCS12) file for your client certificates.  There
  is a bug in the JSSE libraries that require you to have at least a six character
  password on your key (at least for the keytool utility that comes with your
  JDK).
</p>
<p>
  To select the client certificate, choose Options-&gt;SSL Manager from the menu bar.
  You will be presented with a file finder that looks for PKCS12 files by default.
  Your PKCS12 file must have the extension '.p12' for SSL Manager to recognize it
  as a PKCS12 file.  Any other file will be treated like an average JKS key store.
  If JSSE is correctly installed, you will be prompted for the password.  The text
  box does not hide the characters you type at this point--so make sure no one is
  looking over your shoulder.  The current implementation assumes that the password
  for the keystore is also the password for the private key of the client you want
  to authenticate as.
</p>
<p>
  The next time you run your test, the SSL Manager will examine your key store to
  see if it has more than one key available to it.  If there is only one key, SSL
  Manager will select it for you.  If there is more than one key, you will be prompted
  to select the alias you wish to authenticate as.  If SSL Manager cannot detect
  any keys in your keystore, it will give you a text box for the off chance you know
  something it doesn't.  Keep in mind that for the first run, you will be prompted
  once per thread.  Try to use only one thread for the first run to ensure everything
  is working properly.
</p>
<b>Things to Look Out For</b>
<p>
  You must have your Certificate Authority (CA) certificate installed properly
  if it is not signed by one of the five CA certificates that ships with your
  JDK.  One method to install it is to import your CA certificate into a JKS
  file, and name the JKS file "jssecacerts".  Place the file in your JRE's
  lib/security folder.  This file will be read before the "cacerts" file in
  the same directory.  Keep in mind that as long as the "jssecacerts" file
  exists, the certificates installed in "cacerts" will not be used.  This may
  cause problems for you.  If you don't mind importing your CA certificate into
  the "cacerts" file, then you can authenticate against all of the CA certificates
  installed.
</p>
</component>
</section>
</body>
</document>
